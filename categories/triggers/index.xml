<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>triggers on Jess Pomfret</title><link>https://jpomfret.github.io/categories/triggers/</link><description>Recent content in triggers on Jess Pomfret</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 19 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://jpomfret.github.io/categories/triggers/index.xml" rel="self" type="application/rss+xml"/><item><title>Disable all Triggers on a Database</title><link>https://jpomfret.github.io/p/disable-all-triggers-on-a-database/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>https://jpomfret.github.io/p/disable-all-triggers-on-a-database/</guid><description>&lt;p>Sometimes it’s best not to ask why. However, if for some reason you have a number of triggers on tables within a database that you would like to temporarily disable, read on.&lt;/p>
&lt;p>I came across a situation recently while automating a process to refresh test environments where this exact scenario came up.  As part of the process several scripts were run to obfuscate production data. While these ran all the UPDATE triggers were firing. Not only were the triggers adding a significant amount of time to the process, they were also updating dates and other values that we’d prefer kept their original values.&lt;/p>
&lt;p>Now, as I mentioned this is not a discussion on whether this is a good database design or not, this is just how to solve this issue.&lt;/p>
&lt;p>In the snippet below I use &lt;code>Connect-DbaInstance&lt;/code> from &lt;a class="link" href="http://dbatools.io" target="_blank" rel="noopener"
>dbatools&lt;/a> to create a &lt;code>$svr&lt;/code> object. If you don’t have dbatools installed you could either &lt;a class="link" href="http://dbatools.io/install" target="_blank" rel="noopener"
>install dbatools&lt;/a>, or use &lt;code>New-Object Microsoft.SqlServer.Management.Smo.Server&lt;/code>. The dbatools function is essentially a wrapper around this command that adds a lot of additional checks and options.&lt;/p>
&lt;p>I have also defined an array &lt;code>$triggers&lt;/code> to keep track of the triggers I disable. It’s likely that you’ll want to put the environment back to how it started, so this will make sure you don’t enable any triggers that started off disabled.&lt;/p>
&lt;p>Then we get to the actual work. Using the &lt;code>$svr&lt;/code> object we can loop through all the tables, and then all the triggers on those tables. If a certain trigger is enabled, it is added to the &lt;code>$triggers&lt;/code> array and then disabled using &lt;code>$tr.isenabled&lt;/code>.  As with most (all?) changes made through SMO you then need to call the alter method ,&lt;code>$tr.alter()&lt;/code>, to actually make the change on the server.&lt;/p>
&lt;p>$database = ‘AdventureWorks2017’
$svr = Connect-DbaInstance -SqlInstance server1
$foreach ($tbl in $svr.databases[$database].Tables)
{
foreach ($tr in $($tbl.Triggers | Where-Object Isenabled)) {
$triggers += $tr | Select-Object @{l=&amp;lsquo;SchemaName&amp;rsquo;;e={$tbl.Schema}}, @{l=&amp;lsquo;TableName&amp;rsquo;;e={$tbl.name}}, @{l=&amp;lsquo;TriggerName&amp;rsquo;;e={$_.name}}
$tr.isenabled = $FALSE
$tr.alter()
}
}&lt;/p>
&lt;p>When you are ready to enable the triggers again you can use the following code. This loops through the triggers that we had previously disabled and added to our array and enables them.&lt;/p>
&lt;p>foreach($tr in $triggers) {
$trigger = $svr.Databases[$database].Tables[$tr.TableName,$tr.SchemaName].Triggers[$tr.TriggerName]
$trigger.IsEnabled = $true
$trigger.alter()
}&lt;/p></description></item><item><title>Execution of Multiple Triggers on one Table</title><link>https://jpomfret.github.io/p/execution-of-multiple-triggers-on-one-table/</link><pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate><guid>https://jpomfret.github.io/p/execution-of-multiple-triggers-on-one-table/</guid><description>&lt;p>Well it has been a little quiet here recently. I just (or it’s been two weeks now) got back from a 2 week trip to England and France. It was an amazing trip and there are a few pictures on &lt;a class="link" href="https://www.instagram.com/jpomfret/" target="_blank" rel="noopener"
>Instagram&lt;/a> if you are curious about what I got up to.&lt;/p>
&lt;p>This is also going to be a quick post. I asked a question on Twitter last week about what happens when you have multiple triggers on a table. I got the answer (Thanks Aaron!), but figured this would be a good thing to demonstrate.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>I have also been playing with Azure Data Studio and the new notebook feature, so I answered this question with a step-by-step example in a notebook. I also found that you can easily store these notebooks on GitHub so I have uploaded it to my demos repo for you to follow along.&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/jpomfret/demos/blob/master/Notebooks/TriggerOrder.ipynb" target="_blank" rel="noopener"
>Trigger Order Notebook&lt;/a>&lt;/p>
&lt;p>TL;DR: Triggers execute one after the other. I demonstrated this by creating a table with three insert triggers that each waited 2 seconds and recorded the timestamp.&lt;/p></description></item></channel></rss>