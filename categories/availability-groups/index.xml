<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>availability-groups on Jess Pomfret</title><link>https://jpomfret.github.io/categories/availability-groups/</link><description>Recent content in availability-groups on Jess Pomfret</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Tue, 16 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://jpomfret.github.io/categories/availability-groups/index.xml" rel="self" type="application/rss+xml"/><item><title>Collating index usage stats across Availability Group replicas</title><link>https://jpomfret.github.io/p/collating-index-usage-stats-across-availability-group-replicas/</link><pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate><guid>https://jpomfret.github.io/p/collating-index-usage-stats-across-availability-group-replicas/</guid><description>&lt;p>One of the benefits available to us when using SQL Server Availability Groups is that we can offload read activity to a secondary replica. This can be useful if we need to run reports against our OLTP databases. Instead of this taking up valuable resources on the primary instance we can make use of the otherwise idle secondary replica.&lt;/p>
&lt;p>Note: This could affect your licensing standpoint, so ensure you’re in compliance on that front.&lt;/p>
&lt;p>Last week, I was working on a project to analyse indexes on a database that was part of an availability group. The main goal was to find unused indexes that could be removed, but I was also interested in gaining an overall understanding of how the system was indexed.&lt;/p>
&lt;p>Unused indexes not only take up disk space, but they also add overhead to write operations and require maintenance which can add additional load on your system.  We can also use this analysis to look for a high number of lookups which could indicate we need to adjust indexes slightly.&lt;/p>
&lt;p>&lt;strong>&lt;em>Note&lt;/em>&lt;/strong>: dbatools does have a command called &lt;code>Find-DbaDbUnusedIndex&lt;/code> to just look for unused indexes – however since I wanted to collect overall usage as well it wasn’t appropriate in this situation.&lt;/p>
&lt;p>dbatools has a command &lt;code>Get-DbaHelpIndex&lt;/code> which returns detailed information on our indexes which we can then use to complete the necessary analysis. To run this against a single database we could use the following code:&lt;/p>
&lt;p>Get-DbaHelpIndex -SqlInstsance mssql1 -Database AdventureWorks | Out-GridView&lt;/p>
&lt;p>In the above example I’ve used &lt;code>Out-GridView&lt;/code> to popup the results in a nice, easy to view GUI. I love using this output option to get a feel for the results. You can also filter and sort to help do some initial analysis to help get an understanding of your data.&lt;/p>
&lt;p>This is perfect – except I mentioned this database was in an AG. Oh, and it is set up to take advantage of using that read-only replica to run reporting against. That means the whole picture of the index usage is spread across two instances. We might find a totally unused index on our primary replica, a great candidate to be dropped, unless it’s heavily used by reports on the secondary.&lt;/p>
&lt;p>Remember, the secondary replica is just a read-only copy – so the indexes needed on the secondary must be created on the primary.&lt;/p>
&lt;p>In this situation we need to combine the index stats for both replicas into one easy to use result set – for this we can make use of PowerShell’s PSCustomObject to join these two result sets. In the code below I’ve set up a few variables at the top, and then run &lt;code>Get-DbaHelpIndex&lt;/code> against both instances. We then set up a variable to catch the results in &lt;code>$export&lt;/code> and use foreach-object to loop through the results for the primary instance. As we loop through, we’re looking for the matching index on the secondary replica before adding properties from both sides to the PSCustomObject.&lt;/p>
&lt;p>Finally, we lean on the ImportExcel module to export the results to an excel spreadsheet – if you haven’t checked this module out yet I highly recommend it.&lt;/p>
&lt;p>&lt;a class="link" href="https://gist.github.com/jpomfret/a9afa22c4d1129fecc4ea3e6cde1b51c" target="_blank" rel="noopener"
>https://gist.github.com/jpomfret/a9afa22c4d1129fecc4ea3e6cde1b51c&lt;/a>&lt;/p>
&lt;p>Looking at our results spreadsheet we can now easily review the index usage across both replicas and make sure that any indexes we identify as unused, truly are unused.&lt;/p></description></item><item><title>Testing Availability Group Read-Only Routing with dbatools</title><link>https://jpomfret.github.io/p/testing-availability-group-read-only-routing-with-dbatools/</link><pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate><guid>https://jpomfret.github.io/p/testing-availability-group-read-only-routing-with-dbatools/</guid><description>&lt;p>I recently set up an Availability Group with the intent of using the secondary as a read only replica for reporting.  We have a few AG&amp;rsquo;s in our environment already but currently none are using this feature.&lt;/p>
&lt;p>I&amp;rsquo;m not going to step through setting up the AG or configuring the readable secondary as there are plenty of good posts out there as well as the official &lt;a class="link" href="https://docs.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-read-only-access-on-an-availability-replica-sql-server?view=sql-server-2017" target="_blank" rel="noopener"
>books online documentation&lt;/a>.&lt;/p>
&lt;p>Once my AG was created I set the &amp;lsquo;Connections in Primary Role&amp;rsquo; to &amp;lsquo;Allow read/write connections&amp;rsquo; and the &amp;lsquo;Readable Secondary&amp;rsquo; to &amp;lsquo;Read-intent only&amp;rsquo; as shown below. On a side note it&amp;rsquo;s important to set these for both instances, if you&amp;rsquo;re running with 01B as the Primary after a failover by setting both you&amp;rsquo;ll get the same behavior, with read only connections being routed to the now secondary, 01A server.&lt;/p>
&lt;p>&lt;img src="https://jpomfret.github.io/images/AGReplicas.jpg"
loading="lazy"
>&lt;/p>
&lt;p>The other part I needed to set up was &lt;a class="link" href="https://docs.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-read-only-routing-for-an-availability-group-sql-server?view=sql-server-2017" target="_blank" rel="noopener"
>read-only routing&lt;/a>, this enables SQL Server to reroute those read only connections to the appropriate replica.  You can also list the read only replicas by priority if you have multiple available or you can group them to enable load-balancing.&lt;/p>
&lt;p>Although this seems to be setup correctly so that connections that specify their application intent of read only will be routed to the secondary node I wanted to prove it. I used the &lt;a class="link" href="https://dbatools.io/functions/connect-dbainstance/" target="_blank" rel="noopener"
>Connect-DbaInstance&lt;/a> function from dbatools to connect to the listener name with the -ApplicationIntent property set to &amp;lsquo;ReadOnly&amp;rsquo;.&lt;/p>
&lt;p>$svr = Connect-DbaInstance -SqlInstance AGListenerName `
-Database DatabaseInAG `
-ApplicationIntent ReadOnly&lt;/p>
&lt;p>$svr.Query(&amp;lsquo;Select @@ServerName as ServerName&amp;rsquo;)&lt;/p>
&lt;h2 id="servername">ServerName&lt;/h2>
&lt;p>*******01B&lt;/p>
&lt;p>You can see it routed correctly to 01B which is currently the secondary node.  If I don&amp;rsquo;t specify the ApplicationIntent property on the connection it&amp;rsquo;ll be routed to the primary.&lt;/p>
&lt;p>$svr = Connect-DbaInstance -SqlInstance AGListenerName `
-Database DatabaseInAG&lt;/p>
&lt;p>$svr.Query(&amp;lsquo;Select @@ServerName as ServerName&amp;rsquo;)&lt;/p>
&lt;h2 id="servername-1">ServerName&lt;/h2>
&lt;p>*******01A&lt;/p>
&lt;p>This was a quick and easy way to ensure my read only routing was working as expected, and another great use of dbatools.&lt;/p></description></item></channel></rss>